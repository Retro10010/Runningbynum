<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Бегущий по числам</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
  canvas { display:block; }

  #ui {
    position: absolute; top: 20px; left: 20px;
    color: #ff79c6; font-size: 48px; font-weight: bold;
    text-shadow: 0 0 10px #ff79c6, 0 0 20px #ff79c6, 0 0 40px #ff79c6;
    letter-spacing: 4px; pointer-events: none; z-index: 10; transition: all 0.3s;
  }
  #ui.pulse { transform: scale(1.15); }

  #level {
    position: absolute; top: 90px; left: 20px;
    color: #50fa7b; font-size: 36px; font-weight: bold;
    text-shadow: 0 0 15px #50fa7b; letter-spacing: 3px;
    pointer-events: none; z-index: 10;
  }

  #challenge {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 600px; padding: 50px;
    background: rgba(20,15,40,0.97);
    border: 6px solid #bd93f9; border-radius: 35px;
    box-shadow: 0 0 80px #bd93f9, inset 0 0 40px rgba(189,147,249,0.3);
    display: none; flex-direction: column; align-items: center; gap: 40px;
    z-index: 100; animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }
  @keyframes pop {
    from { transform: translate(-50%, -50%) scale(0.3); opacity: 0; }
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }
  #equation { font-size: 100px; color: #ffb86c; text-shadow: 0 0 50px #ffb86c; letter-spacing: 6px; }
  #timer { font-size: 140px; color: #ff5555; text-shadow: 0 0 60px #ff5555; animation: timerPulse 1s infinite alternate; }
  @keyframes timerPulse { from { opacity: 0.8; } to { opacity: 1; transform: scale(1.05); } }
  #input {
    font-size: 80px; width: 380px; padding: 20px; text-align: center;
    background: #1e1e2e; border: 6px solid #6272a4; color: #f8f8f2;
    border-radius: 25px; outline: none; transition: all 0.3s;
  }
  #input:focus { border-color: #50fa7b; box-shadow: 0 0 40px #50fa7b; transform: scale(1.05); }

  #startScreen, #gameOver {
    position: absolute; inset: 0;
    background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    color: #ff79c6; display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 60px; z-index: 200;
    font-size: 50px; text-align: center;
  }
  h1 {
    font-size: 90px; text-shadow: 0 0 40px #ff79c6;
    background: linear-gradient(90deg, #ff79c6, #bd93f9, #8be9fd);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    animation: titleGlow 3s infinite alternate;
  }
  @keyframes titleGlow { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(60deg); } }
  button {
    padding: 30px 100px; font-size: 50px; font-weight: bold;
    background: linear-gradient(45deg, #bd93f9, #ff79c6);
    color: #282a36; border: none; border-radius: 30px; cursor: pointer;
    box-shadow: 0 0 40px rgba(189,147,249,0.6); transition: all 0.4s;
  }
  button:hover { transform: translateY(-10px) scale(1.1); box-shadow: 0 0 80px #ff79c6; }
</style>
</head>
<body>
<div id="startScreen">
  <h1>БЕГУЩИЙ ПО ЧИСЛАМ</h1>
  <p style="font-size:42px;opacity:0.9;">Реши пример за 5 секунд — прыгни через препятствие!</p>
  <button id="startButton">ИГРАТЬ</button>
</div>

<div id="gameOver" style="display:none">
  <h1>ИГРА ОКОНЧЕНА</h1>
  <p style="font-size:50px;">Твой счёт: <span id="finalScore" style="color:#ffb86c;font-size:70px;">0</span></p>
  <button id="restartButton">ИГРАТЬ СНОВА</button>
</div>

<div id="ui">СЧЁТ: <span id="score">0</span></div>
<div id="level">УРОВЕНЬ 1</div>

<div id="challenge">
  <div id="equation">7 × 8 = ?</div>
  <div id="timer">5.0</div>
  <input id="input" type="text" inputmode="numeric" placeholder="Ответ">
</div>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;

const GROUND_Y = canvas.height - 120;
const GRAVITY = 0.6;
const JUMP_POWER = -16;

let player = { x: 150, y: GROUND_Y - 90, vy: 0, width: 70, height: 90, jumping: false };
let obstacles = [];
let particles = [];
let stars = [];
let score = 0;
let gameSpeed = 5;
let gameRunning = false;
let gamePaused = false;
let nextSpawnTime = 0;

const challengeDiv = document.getElementById('challenge');
const equationDiv = document.getElementById('equation');
const timerDiv = document.getElementById('timer');
const input = document.getElementById('input');
const scoreDisplay = document.getElementById('score');
const levelDisplay = document.getElementById('level');
const ui = document.getElementById('ui');

let currentObstacle = null;
let timerInterval = null;
let answerLocked = false;

// === Система уровней ===
function getLevel() {
  if (score < 500) return 1;
  if (score < 1000) return 2;
  return 3;
}

function updateLevelDisplay() {
  const level = getLevel();
  if (level === 1) levelDisplay.textContent = "УРОВЕНЬ 1 — ПРОСТЫЕ";
  else if (level === 2) levelDisplay.textContent = "УРОВЕНЬ 2 — СТЕПЕНИ";
  else levelDisplay.textContent = "УРОВЕНЬ 3 — УРАВНЕНИЯ";
}

// === Генерация задач по уровню ===
function generateTask() {
  const level = getLevel();
  const r = Math.random();

  if (level === 1) {
    // Только умножение и деление
    if (r < 0.5) {
      let a = Math.floor(Math.random()*10)+2, b = Math.floor(Math.random()*10)+2;
      return {text: `${a} × ${b}`, answer: String(a*b)};
    } else {
      let b = Math.floor(Math.random()*8)+2;
      let a = b * (Math.floor(Math.random()*9)+2);
      return {text: `${a} ÷ ${b}`, answer: String(a/b)};
    }
  }

  if (level === 2) {
    // Умножение, деление + степени
    if (r < 0.5) {
      let a = Math.floor(Math.random()*10)+2, b = Math.floor(Math.random()*10)+2;
      return {text: `${a} × ${b}`, answer: String(a*b)};
    } else if (r < 0.75) {
      let b = Math.floor(Math.random()*8)+2;
      let a = b * (Math.floor(Math.random()*9)+2);
      return {text: `${a} ÷ ${b}`, answer: String(a/b)};
    } else if (r < 0.9) {
      let a = Math.floor(Math.random()*10)+2;
      return {text: `${a}²`, answer: String(a*a)};
    } else {
      let a = Math.floor(Math.random()*5)+2;
      return {text: `${a}³`, answer: String(a*a*a)};
    }
  }

  // Уровень 3 — уравнения
  if (level >= 3) {
    const type = Math.floor(Math.random()*4);
    if (type === 0) { // ax = b
      let a = Math.floor(Math.random()*8)+2;
      let x = Math.floor(Math.random()*12)+1;
      let b = a * x;
      return {text: `${a}x = ${b}`, answer: String(x)};
    } else if (type === 1) { // x + a = b
      let a = Math.floor(Math.random()*20)+5;
      let x = Math.floor(Math.random()*30)+1;
      let b = x + a;
      return {text: `x + ${a} = ${b}`, answer: String(x)};
    } else if (type === 2) { // x - a = b
      let a = Math.floor(Math.random()*20)+5;
      let x = Math.floor(Math.random()*30)+a+1;
      let b = x - a;
      return {text: `x − ${a} = ${b}`, answer: String(x)};
    } else { // a - x = b
      let a = Math.floor(Math.random()*40)+10;
      let x = Math.floor(Math.random()*20)+1;
      let b = a - x;
      return {text: `${a} − x = ${b}`, answer: String(x)};
    }
  }
}

// === Остальное без изменений ===
function initStars() {
  stars = [];
  for(let i = 0; i < 200; i++) {
    stars.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.7,
      size: Math.random() * 3,
      speed: 0.2 + Math.random() * 0.8,
      opacity: Math.random()
    });
  }
}
initStars();

function updateScore(add) {
  score += add;
  scoreDisplay.textContent = score;
  ui.classList.add('pulse');
  setTimeout(() => ui.classList.remove('pulse'), 400);
  updateLevelDisplay();
}

document.getElementById('startButton').onclick = startGame;
document.getElementById('restartButton').onclick = startGame;

class Obstacle {
  constructor() {
    this.x = canvas.width + 100;
    this.y = GROUND_Y - 100;
    this.width = 90;
    this.height = 110;
    this.task = generateTask();
    this.solved = false;
    this.shape = ['square','triangle','circle','pentagon'][Math.floor(Math.random()*4)];
  }
  update() { if (!gamePaused) this.x -= gameSpeed; }
  draw() {
    ctx.save();
    ctx.translate(this.x + this.width/2, this.y + this.height/2);
    ctx.fillStyle = this.solved ? '#50fa7b' : '#ffb86c';
    ctx.strokeStyle = this.solved ? '#50fa7b' : '#ff6b6b';
    ctx.lineWidth = 8;
    ctx.shadowBlur = 30;
    ctx.shadowColor = this.solved ? '#50fa7b' : '#ffb86c';
    if (this.shape === 'square') { ctx.fillRect(-40,-50,80,100); ctx.strokeRect(-40,-50,80,100); }
    else if (this.shape === 'triangle') { ctx.beginPath(); ctx.moveTo(0,-50); ctx.lineTo(-45,50); ctx.lineTo(45,50); ctx.closePath(); ctx.fill(); ctx.stroke(); }
    else if (this.shape === 'circle') { ctx.beginPath(); ctx.arc(0,0,48,0,Math.PI*2); ctx.fill(); ctx.stroke(); }
    else {
      ctx.beginPath();
      for(let i=0;i<5;i++){
        let a = i/5*Math.PI*2 - Math.PI/2;
        let x = Math.cos(a)*48, y = Math.sin(a)*48;
        i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }
}

function particlesBurst(x, y, color) {
  for(let i=0; i<80; i++) {
    particles.push({x, y, vx: Math.random()*30-15, vy: Math.random()*30-20, life: 50, color, size: Math.random()*8+4});
  }
}

function makePlayerJump() {
  if (!player.jumping && !gamePaused) {
    player.vy = JUMP_POWER;
    player.jumping = true;
    particlesBurst(player.x + 35, player.y + 80, '#8be9fd');
  }
}

function startChallenge(obs) {
  if (currentObstacle || gamePaused) return;
  gamePaused = true;
  currentObstacle = obs;
  equationDiv.textContent = obs.task.text + ' = ?';
  let timeLeft = 5.0;
  timerDiv.textContent = '5.0';
  input.value = '';
  challengeDiv.style.display = 'flex';
  setTimeout(() => input.focus(), 150);

  timerInterval = setInterval(() => {
    timeLeft -= 0.1;
    timerDiv.textContent = timeLeft.toFixed(1);
    if (timeLeft <= 0) {
      clearInterval(timerInterval);
      particlesBurst(obs.x + 45, obs.y + 55, '#ff5555');
      challengeDiv.style.display = 'none';
      setTimeout(gameOver, 800);
    }
  }, 100);
}

input.onkeydown = function(e) {
  if (e.key === 'Enter' && gamePaused && !answerLocked) {
    e.preventDefault();
    answerLocked = true;
    clearInterval(timerInterval);

    const correct = input.value.trim() === currentObstacle.task.answer;
    if (correct) {
      currentObstacle.solved = true;
      particlesBurst(currentObstacle.x + 45, currentObstacle.y + 55, '#50fa7b');
      updateScore(50);  // +50 очков
      challengeDiv.style.display = 'none';
      gamePaused = false;
      makePlayerJump();

      setTimeout(() => {
        const i = obstacles.indexOf(currentObstacle);
        if (i > -1) obstacles.splice(i, 1);
        currentObstacle = null;
        answerLocked = false;
      }, 1200);
    } else {
      particlesBurst(currentObstacle.x + 45, currentObstacle.y + 55, '#ff5555');
      challengeDiv.style.display = 'none';
      gamePaused = false;
      setTimeout(() => { gameOver(); answerLocked = false; }, 800);
    }
  }
};

function drawPlayer() {
  const swing = player.jumping ? 0 : Math.sin(Date.now() * 0.018) * 28;
  ctx.shadowBlur = 30; ctx.shadowColor = '#8be9fd';
  ctx.fillStyle = '#8be9fd'; ctx.fillRect(player.x + 10, player.y, 50, 70);
  ctx.fillStyle = '#6272a4';
  ctx.beginPath(); ctx.arc(player.x + 35, player.y + 20, 28, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#f8f8f2';
  ctx.beginPath(); ctx.arc(player.x + 35, player.y + 20, 15, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle = '#ff79c6'; ctx.lineWidth = 14; ctx.lineCap = 'round'; ctx.shadowColor = '#ff79c6';
  ctx.beginPath();
  ctx.moveTo(player.x + 25, player.y + 70);
  ctx.lineTo(player.x + 25 + swing, player.y + 105);
  ctx.moveTo(player.x + 45, player.y + 70);
  ctx.lineTo(player.x + 45 - swing, player.y + 105);
  ctx.stroke();
}

function drawBackground() {
  const time = Date.now() * 0.0003;
  const grad = ctx.createLinearGradient(0,0, canvas.width, canvas.height);
  grad.addColorStop(0, `hsl(${240 + Math.sin(time)*30}, 80%, 15%)`);
  grad.addColorStop(0.5, `hsl(${280 + Math.sin(time+1)*20}, 70%, 10%)`);
  grad.addColorStop(1, `hsl(${300 + Math.cos(time)*15}, 60%, 5%)`);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!gamePaused) {
    stars.forEach(s => {
      s.x -= s.speed * gameSpeed * 0.3;
      if (s.x < 0) s.x = canvas.width;
    });
  }
  stars.forEach(s => {
    ctx.globalAlpha = s.opacity + Math.sin(Date.now()*0.003 + s.x)*0.3;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(s.x, s.y, s.size, s.size);
  });
  ctx.globalAlpha = 1;

  const groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, canvas.height);
  groundGrad.addColorStop(0, '#6272a4');
  groundGrad.addColorStop(1, '#282a36');
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

  ctx.strokeStyle = '#ff79c6'; ctx.lineWidth = 6; ctx.shadowBlur = 30; ctx.shadowColor = '#ff79c6';
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(canvas.width, GROUND_Y); ctx.stroke();
  ctx.shadowBlur = 0;
}

function loop() {
  if (!gameRunning) return;
  drawBackground();

  const sunX = canvas.width - 200 + Math.sin(Date.now()*0.0005)*30;
  const sunY = 130 + Math.cos(Date.now()*0.0004)*20;
  const sunGrad = ctx.createRadialGradient(sunX, sunY, 0, sunX, sunY, 120);
  sunGrad.addColorStop(0, '#ffb86c'); sunGrad.addColorStop(0.4, '#ff79c6'); sunGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = sunGrad; ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!gamePaused) {
    player.vy += GRAVITY; player.y += player.vy;
    if (player.y >= GROUND_Y - 90) { player.y = GROUND_Y - 90; player.vy = 0; player.jumping = false; }

    if (performance.now() > nextSpawnTime && obstacles.length === 0) {
      obstacles.push(new Obstacle());
      nextSpawnTime = performance.now() + 5000;
    }

    obstacles.forEach(obs => {
      obs.update(); obs.draw();
      if (!currentObstacle && obs.x <= player.x + 110 && obs.x >= player.x - 30) {
        startChallenge(obs);
      }
    });

    for (let i = obstacles.length-1; i >= 0; i--) {
      if (obstacles[i].x < -200) {
        obstacles.splice(i, 1);
        gameSpeed += 0.02;
      }
    }

    particles = particles.filter(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.4; p.life--;
      ctx.globalAlpha = p.life/50; ctx.fillStyle = p.color; ctx.shadowBlur = 20; ctx.shadowColor = p.color;
      ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
      return p.life > 0;
    });
    ctx.globalAlpha = 1; ctx.shadowBlur = 0;
  }

  drawPlayer();
  requestAnimationFrame(loop);
}

function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  obstacles = []; particles = []; score = 0; gameSpeed = 5;
  player = { x: 150, y: GROUND_Y - 90, vy: 0, width: 70, height: 90, jumping: false };
  currentObstacle = null; gamePaused = false; answerLocked = false;
  nextSpawnTime = performance.now() + 4000;
  scoreDisplay.textContent = '0';
  updateLevelDisplay();
  challengeDiv.style.display = 'none';
  initStars();
  gameRunning = true;
  loop();
}

function gameOver() {
  gameRunning = false;
  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameOver').style.display = 'flex';
  challengeDiv.style.display = 'none';
}

window.addEventListener('resize', () => {
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  initStars();
});
</script>
</body>
</html>